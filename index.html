<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>dodori LAB</title>
<style>
  :root{
    --accent:#3B82F6;
    --bg:#f6f7f9; --card:#fff; --ink:#111; --line:#e5e7eb;
    --pink-btn:#FDE7EF;   /* 연한 분홍 */
    --pink-text:#9D174D;  /* 와인 텍스트 */
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:980px;margin:0 auto;padding:28px 16px}

  .overline{font-size:12px;letter-spacing:.02em;color:#6b7280;text-align:center;margin-bottom:4px}
  h1{margin:8px 0 22px;font-size:32px;text-align:center;color:#000}

  .grid{display:grid;gap:20px}
  @media(min-width:900px){.grid{grid-template-columns:560px 1fr}}

  .card{background:var(--card);border-radius:18px;box-shadow:0 8px 24px rgba(0,0,0,.08);overflow:hidden}
  .pad{padding:20px}
  @media (max-width:480px){ .pad{padding:16px} }

  /* 휠 */
  .wheel-box{width:min(100%,520px);margin:0 auto;}  /* 모바일 잘림 방지 */
  .wheel-wrap{position:relative;width:100%;aspect-ratio:1/1;}
  svg{width:100%;height:100%;display:block}
  #slices,#labels{transform-box:fill-box;transform-origin:50% 50%}

  /* 상단 핀 */
  .pin{position:absolute;left:50%;transform:translateX(-50%);top:-4px;width:0;height:0;
       border-left:14px solid transparent;border-right:14px solid transparent;
       border-top:24px solid var(--accent);filter:drop-shadow(0 2px 2px rgba(0,0,0,.25))}

  .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;justify-content:center}
  button{border:0;border-radius:12px;padding:12px 18px;font:inherit;cursor:pointer}
  .primary{background:var(--accent);color:#fff}
  .ghost{background:#eef4ff;color:#3B82F6}

  /* 삭제/모두삭제 연한 분홍 */
  .danger{ background:var(--pink-btn); color:var(--pink-text); }

  .result{font-weight:700;font-size:20px;margin:16px 0 0;text-align:center}

  .inputs-title{margin:0 0 6px;font-size:18px}
  .inputs{display:flex;flex-direction:column;gap:8px;margin-top:10px}
  .input-row{display:flex;gap:8px}
  .input-row input{flex:1;border:1px solid var(--line);border-radius:10px;padding:10px 12px;font:inherit}

  /* 회전 트랜지션 */
  .spin-transition{transition:transform 4s cubic-bezier(0.2,0.8,0.2,1)}
</style>
</head>
<body>
<div class="wrap">
  <div class="overline">dodori LAB - Connect Anything, Create Everything</div>
  <h1>어떤 재료를 사용해 볼까요?</h1>

  <div class="grid">
    <!-- 왼쪽: 돌림판 -->
    <div class="card pad">
      <div class="wheel-box">
        <div class="wheel-wrap">
          <div class="pin"></div>
          <svg viewBox="-50 -50 100 100" aria-label="랜덤 돌림판">
            <g id="slices" class="spin-transition"></g>
            <g id="labels" class="spin-transition"></g>
          </svg>
        </div>
      </div>

      <div class="row">
        <button id="spin" class="primary">돌리기</button>
      </div>
      <div id="result" class="result">선택된 재료가 여기에 표시됩니다</div>
    </div>

    <!-- 오른쪽: 입력창 -->
    <div class="card pad">
      <h2 class="inputs-title">수집한 재료를 입력해 주세요.</h2>
      <div class="inputs" id="inputs"></div>
      <div class="row">
        <button id="add" class="ghost">항목 추가</button>
        <button id="clear" class="danger">모두 삭제</button>
      </div>
    </div>
  </div>
</div>

<script>
  /* ===== 유틸 ===== */
  const deg2rad = d => d * Math.PI / 180;

  /* 파스텔 팔레트: 균등 분포 (레거시 hsl 표기) */
  function pastelHSL(i, n){
    const h = Math.round((360 * i) / n);
    const s = 70, l = 85;
    return `hsl(${h}, ${s}%, ${l}%)`;
  }

  /* 섹터 중심 반지름 (텍스트는 조금 더 안쪽) */
  const sectorCentroidR = (R, thetaRad) => {
    const half = thetaRad/2;
    if (half === 0) return R*0.6;
    const r = (2*R*Math.sin(half)) / (3*half);
    return Math.min(R*0.82, Math.max(R*0.38, r));
  };

  /* ===== 상태/DOM ===== */
  let gSlices, gLabels, inputsBox, resultEl, btnSpin, btnAdd, btnClear;
  let items = ["병뚜껑","종이","빨대","멸균팩"];
  let isSpinning = false;
  const SPIN_TURNS_DEG = 360 * 10;
  let currentDeg = 0;

  /* 폰트 크기: 반지름 중심을 기준으로 좌우(안/바깥)로 같은 여백이 남도록 계산 */
  function computeFontSizeCentered(label, innerBound, outerBound){
    const maxSize = 5.5, minSize = 2.6;
    const len = Math.max(1, [...label].length);
    const lineFactor = 1.08;
    // step = size * lineFactor
    // 중심에서 끝 글자까지의 반경 필요량 = step * (len - 1)/2
    // 허용 최대 반경 절반폭 = Math.min(targetCenter - innerBound, outerBound - targetCenter) (targetCenter는 이후에 정해짐)
    // targetCenter는 섹션 중앙반지름이므로, 이 함수 안에선 반환 시 lineFactor만 넘겨주고,
    // 사이즈는 drawWheel에서 실제 중앙반경으로 클램프한다.
    return { minSize, maxSize, lineFactor };
  }

  /* 각 섹션 라벨 그리기: 문자열 중심 고정 배치 */
  function drawCenteredVerticalLabel(group, textStr, midDeg, targetCenter, innerBound, outerBound){
    const { minSize, maxSize, lineFactor } = computeFontSizeCentered(textStr, innerBound, outerBound);
    const len = Math.max(1, [...textStr].length);

    // 먼저 큰 폰트에서 시작 → 경계 안에 모두 들어오도록 줄임
    let fontSize = maxSize;
    const halfCount = (len - 1) / 2;

    // 경계 내에 들어오기 위한 최대 폰트
    // halfExtent = step * halfCount <= maxHalf
    const maxHalfRadial = Math.max(1, Math.min(targetCenter - innerBound, outerBound - targetCenter));
    if (halfCount > 0){
      const limitByRadial = (maxHalfRadial * 1) / (halfCount * lineFactor);
      fontSize = Math.min(fontSize, limitByRadial);
    }
    fontSize = Math.max(minSize, Math.min(maxSize, fontSize));

    const step = fontSize * lineFactor;

    // 그룹: 각 섹션 중앙각도로만 회전
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform', `rotate(${midDeg})`);
    group.appendChild(g);

    // 텍스트 노드(수직 중앙은 우리가 직접 맞추므로 dominant-baseline 불필요)
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('text-anchor','middle');
    t.setAttribute('font-size', fontSize.toFixed(2));
    t.setAttribute('font-weight','700');
    t.setAttribute('fill','#111');

    // 각 글자를 tspan으로 쪼개서 "가운데 글자"가 정확히 targetCenter에 오도록 배치
    const chars = [...textStr];
    const midIndex = Math.floor((len - 1) / 2);

    for(let i=0;i<len;i++){
      const span = document.createElementNS('http://www.w3.org/2000/svg','tspan');
      span.setAttribute('x','0');

      // i가 클수록 바깥쪽으로 이동(핀 쪽으로)하도록 y를 음수 방향으로 이동
      const offset = (i - midIndex) * step;
      const y = -(targetCenter + offset);
      span.setAttribute('y', y.toFixed(2));
      span.textContent = chars[i];
      t.appendChild(span);
    }

    g.appendChild(t);
  }

  function drawWheel(){
    const n = items.length;
    gSlices.innerHTML = '';
    gLabels.innerHTML = '';

    if(n === 0){
      // 항목 없을 때 연회색 원 유지
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('cx','0'); circle.setAttribute('cy','0'); circle.setAttribute('r','48');
      circle.setAttribute('fill','#E5E7EB');
      gSlices.appendChild(circle);
      gSlices.style.transform = `rotate(0deg)`;
      gLabels.style.transform = `rotate(0deg)`;
      return;
    }

    const slice = 360/n;
    const theta = deg2rad(slice);

    for (let i=0;i<n;i++){
      const start = i*slice - 90;
      const end   = (i+1)*slice - 90;
      const large = slice > 180 ? 1 : 0;

      const x1 = 48*Math.cos(deg2rad(start)), y1 = 48*Math.sin(deg2rad(start));
      const x2 = 48*Math.cos(deg2rad(end)),   y2 = 48*Math.sin(deg2rad(end));

      // 조각
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', `M0 0 L ${x1} ${y1} A 48 48 0 ${large} 1 ${x2} ${y2} Z`);
      p.setAttribute('fill', pastelHSL(i,n));
      gSlices.appendChild(p);

      // 라벨 (문자열 중심을 반지름 중앙에 고정)
      const mid = start + slice/2;
      const label = (items[i] ?? '').toString().trim() || '항목';

      // 반지름 중앙/경계
      const rCenter = sectorCentroidR(42, theta);        // 섹션의 기하학적 중심 근처
      const innerBound = 6;                               // 너무 안쪽으로 들어가지 않도록
      const outerBound = 46;                              // 원 경계선 바로 안쪽
      const targetCenter = Math.max(innerBound+2, Math.min(outerBound-2, rCenter));

      drawCenteredVerticalLabel(gLabels, label, mid, targetCenter, innerBound, outerBound);
    }

    gSlices.style.transform = `rotate(${currentDeg}deg)`;
    gLabels.style.transform = `rotate(${currentDeg}deg)`;
  }

  /* ===== 입력창 ===== */
  function ensureOneRow(){
    if (inputsBox.children.length === 0) addRow('');
  }

  function rowTemplate(value=''){
    const row = document.createElement('div');
    row.className = 'input-row';
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = '예 : 휴지심';
    input.value = value;
    const del = document.createElement('button');
    del.textContent = '삭제';
    del.className = 'danger';
    row.appendChild(input); row.appendChild(del);

    input.addEventListener('input', syncFromInputs);
    input.addEventListener('keydown', e=>{
      if(e.key==='Enter'){ e.preventDefault(); addRow(); }
    });
    del.addEventListener('click', ()=>{
      row.remove();
      ensureOneRow();
      syncFromInputs();
    });
    return row;
  }

  function renderInputs(){
    inputsBox.innerHTML='';
    (items.length?items:['']).forEach(v=>inputsBox.appendChild(rowTemplate(v)));
  }

  function collectItems(){
    return Array.from(inputsBox.querySelectorAll('input'))
      .map(i=>i.value.trim())
      .filter(Boolean);
  }

  function syncFromInputs(){
    items = collectItems();
    drawWheel();
    resultEl.textContent = '선택된 재료가 여기에 표시됩니다';
  }

  function addRow(value=''){
    inputsBox.appendChild(rowTemplate(value));
    inputsBox.lastChild.querySelector('input').focus();
  }

  /* ==== 스핀: 누적 회전 + 최종 각도로 역산 ==== */
  function spinOnce(){
    if(isSpinning) return;
    if(!items.length){ alert('항목을 1개 이상 입력해 주세요.'); return; }
    isSpinning = true; btnSpin.disabled = true;

    const n = items.length;
    const slice = 360/n;

    // 랜덤 목표 섹션 하나 선택 → 그 섹션의 중앙이 핀(12시) 아래로 오도록 회전량 계산
    const targetIndex = Math.floor(Math.random()*n);
    const mid = targetIndex*slice + slice/2;
    const alignToTop = 360 - mid;
    const need = (alignToTop - (currentDeg % 360) + 360) % 360;

    currentDeg += SPIN_TURNS_DEG + need;

    gSlices.style.transform = `rotate(${currentDeg}deg)`;
    gLabels.style.transform = `rotate(${currentDeg}deg)`;

    const onEnd = () => {
      gSlices.removeEventListener('transitionend', onEnd);
      isSpinning = false; btnSpin.disabled = false;

      // 실제 최종 각도로 핀이 가리키는 섹션을 역산
      const final = (currentDeg % 360 + 360) % 360;          // 0~359
      const pointerLocal = (360 - final + 90 + 360) % 360;   // 12시=0 보정
      const idx = Math.floor(pointerLocal / slice) % n;

      resultEl.textContent = `선택된 재료: ${items[idx]}`;
    };
    gSlices.addEventListener('transitionend', onEnd, {once:true});
  }

  /* ===== 안전 초기화 ===== */
  window.addEventListener('DOMContentLoaded', () => {
    gSlices   = document.getElementById('slices');
    gLabels   = document.getElementById('labels');
    inputsBox = document.getElementById('inputs');
    resultEl  = document.getElementById('result');
    btnSpin   = document.getElementById('spin');
    btnAdd    = document.getElementById('add');
    btnClear  = document.getElementById('clear');

    btnAdd.addEventListener('click', ()=> addRow());
    btnClear.addEventListener('click', ()=>{
      items = [];
      inputsBox.innerHTML = '';
      addRow('');     // 빈 입력 1개 남김
      drawWheel();    // 회색 원 유지
      resultEl.textContent='선택된 재료가 여기에 표시됩니다';
    });
    btnSpin.addEventListener('click', spinOnce);

    renderInputs();
    drawWheel();
  });
</script>
</body>
</html>
